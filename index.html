<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Retro Space Shooter</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
    <style>
        body {
            margin: 0;
            background: #000;
        }
        #game-container {
            margin: 0 auto;
            display: block;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>

    <script>
        // ====================
        // Start Scene
        // ====================
        class StartScene extends Phaser.Scene {
            constructor() {
                super({ key: 'StartScene' });
            }

            preload() {
                // Load assets
                this.load.image('player', 'assets/player.png');
                this.load.image('enemy', 'assets/enemy.png');
                this.load.image('boss', 'assets/boss.png'); // New Boss Asset
                this.load.image('asteroid_large', 'assets/asteroid_large.png');
                this.load.image('asteroid_medium', 'assets/asteroid_medium.png');
                this.load.image('asteroid_small', 'assets/asteroid_small.png');
                // Removed bullet image loading since we'll create it programmatically
                this.load.audio('shoot', 'assets/sounds/shoot.wav');
                this.load.audio('explosion', 'assets/sounds/explosion.wav');
                this.load.audio('powerup', 'assets/sounds/powerup.wav'); // Added
                this.load.audio('shield', 'assets/sounds/shield.wav');     // Added
                this.load.audio('fire_rate_booster', 'assets/sounds/fire_rate_booster.wav'); // Added
                this.load.audio('invisibility', 'assets/sounds/invisibility.wav'); // Added
                this.load.audio('warp', 'assets/sounds/warp.wav');         // Added
                this.load.audio('collision', 'assets/sounds/collision.wav'); // Added
                this.load.audio('boss_theme', 'assets/sounds/boss_theme.wav'); // New Boss Theme
                this.load.audio('level_up', 'assets/sounds/level_up.wav'); // New Level Up Sound

                // Create a simple star texture if not already created
                if (!this.textures.exists('star')) {
                    const graphics = this.add.graphics();
                    graphics.fillStyle(0xffffff, 1);
                    graphics.fillCircle(2, 2, 2);
                    graphics.generateTexture('star', 4, 4);
                    graphics.destroy();
                }
            }

            create() {
                // Create background
                this.cameras.main.setBackgroundColor('#000');

                // Title Text
                this.add.text(this.scale.width / 2, this.scale.height / 2 - 100, 'Retro Space Shooter', {
                    fontSize: '48px',
                    fill: '#ffffff'
                }).setOrigin(0.5);

                // Instructions
                this.add.text(this.scale.width / 2, this.scale.height / 2, 'Press SPACE to Start', {
                    fontSize: '24px',
                    fill: '#ffffff'
                }).setOrigin(0.5);

                // Input
                this.spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

                // Starfield Background
                this.starGroup = this.add.group({
                    key: 'star',
                    repeat: 500,
                    setXY: { x: 0, y: 0, stepX: 8, stepY: 6 }
                });

                this.starGroup.children.iterate(function (star) {
                    star.setX(Phaser.Math.Between(0, 800));
                    star.setY(Phaser.Math.Between(0, 600));
                    star.setAlpha(Phaser.Math.FloatBetween(0.2, 1));
                });

                // **Create Bullet Texture Programmatically**
                const bulletGraphics = this.add.graphics();
                bulletGraphics.fillStyle(0xff0000, 1); // Red color
                bulletGraphics.fillCircle(2, 2, 2); // Radius 2
                bulletGraphics.generateTexture('bullet', 4, 4); // 4x4 pixels
                bulletGraphics.destroy(); // Clean up graphics object

                // **Create Power-Up Textures Programmatically**
                const powerUpTypes = ['shield', 'fire_rate', 'invisibility', 'warp'];
                const colors = {
                    'shield': 0x00ff00,        // Green
                    'fire_rate': 0xffff00,     // Yellow
                    'invisibility': 0x0000ff,  // Blue
                    'warp': 0xff00ff            // Magenta
                };

                powerUpTypes.forEach(type => {
                    const graphics = this.add.graphics();
                    graphics.fillStyle(colors[type], 1);
                    graphics.fillCircle(16, 16, 16); // Radius 16
                    graphics.generateTexture(type, 32, 32); // 32x32 pixels
                    graphics.destroy();
                });

                // **Log to confirm texture creation**
                console.log('Bullet texture created:', this.textures.exists('bullet'));
                powerUpTypes.forEach(type => {
                    console.log(`${type} texture created:`, this.textures.exists(type));
                });
            }

            update(time, delta) {
                if (Phaser.Input.Keyboard.JustDown(this.spaceBar)) {
                    this.scene.start('GameScene');
                }
            }
        }

        // ====================
        // PowerUp Class
        // ====================
        class PowerUp extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y, type) {
                super(scene, x, y, type); // 'shield', 'fire_rate', 'invisibility', 'warp'
                scene.add.existing(this);
                scene.physics.add.existing(this);
                
                this.type = type;
                this.setActive(true);
                this.setVisible(true);
                this.setOrigin(0.5, 0.5);
                
                // Configure physics properties
                this.setCircle(16); // Adjust based on your power-up sprite size
                this.setImmovable(true);
                this.setScale(1);
                
                // Optional: Add spin effect
                this.scene.tweens.add({
                    targets: this,
                    angle: 360,
                    duration: 2000,
                    repeat: -1
                });
            }
        }

        // ====================
        // Bullet Class
        // ====================
        class Bullet extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y) {
                super(scene, x, y, 'bullet'); // Use the 'bullet' texture
                scene.add.existing(this);
                scene.physics.add.existing(this);

                // Configure bullet properties
                this.setCollideWorldBounds(false);
                this.setActive(false);
                this.setVisible(false);
                this.setOrigin(0.5, 0.5);
                this.lifespan = 2000; // Bullet lifespan in milliseconds
            }

            /**
             * Fires the bullet from a specific position with a given angle and speed.
             * @param {number} x - The x-coordinate to spawn the bullet.
             * @param {number} y - The y-coordinate to spawn the bullet.
             * @param {number} angle - The angle in radians indicating the bullet's direction.
             * @param {number} speed - The speed at which the bullet travels.
             */
            fire(x, y, angle, speed) {
                this.body.reset(x, y); // Reset the bullet's position
                this.setActive(true);
                this.setVisible(true);
                this.setRotation(angle + Math.PI / 2); // Adjust rotation based on angle
                this.setVelocity(Math.cos(angle) * speed, Math.sin(angle) * speed);
                this.lifespan = 2000; // Reset lifespan when fired

                // Optional: Log firing action
                console.log(`Bullet fired at (${x.toFixed(2)}, ${y.toFixed(2)}) with angle ${angle.toFixed(2)} radians and speed ${speed}`);
            }

            /**
             * Updates the bullet's state each frame.
             * @param {number} time - The current time.
             * @param {number} delta - The time elapsed since the last frame.
             */
            update(time, delta) {
                this.lifespan -= delta;
                if (this.lifespan <= 0 || this.isOutOfBounds()) {
                    this.disableBullet();
                }
            }

            /**
             * Checks if the bullet is out of the game world bounds.
             * @returns {boolean} - True if out of bounds, false otherwise.
             */
            isOutOfBounds() {
                return (this.x < 0 || this.x > 4000 || this.y < 0 || this.y > 4000);
            }

            /**
             * Disables the bullet, deactivating it and hiding it from the game.
             */
            disableBullet() {
                this.setActive(false);
                this.setVisible(false);
                this.body.stop(); // Stop the bullet's movement
                this.body.reset(0, 0); // Reset position to origin
                // Optional: Log deactivation
                console.log('Bullet disabled');
            }
        }

        // ====================
        // Player Class
        // ====================
        class Player {
            constructor(scene, x, y, texture) {
                this.scene = scene;
                this.sprite = scene.physics.add.sprite(x, y, texture);
                this.sprite.setScale(0.5);
                this.sprite.setCollideWorldBounds(true);
                this.sprite.setDamping(true);
                this.sprite.setDrag(0.98);
                this.sprite.setAngularDrag(400);
                this.sprite.setMaxVelocity(300);
                this.sprite.setOrigin(0.5, 0.5);
                this.sprite.setAngle(0);
                this.sprite.body.allowRotation = true;

                // Player properties
                this.health = 30;
                this.weaponLevel = 1;
                this.shieldActive = false;
                this.fireRateBoosterActive = false;
                this.invisibilityActive = false;
                
                // **Initialize Firing Variables**
                this.fireRate = 350; // Time between shots in milliseconds
                this.lastFired = 0;   // Timestamp of the last fired bullet
                this.bulletSpeed = 700; // Speed of the bullet in pixels per second

                // Input
                this.keyW = scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);
                this.keyA = scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);
                this.keyS = scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
                this.keyD = scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);
                this.spaceBar = scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
            }

            update() {
                this.handleMovement();
                this.handleShooting();
            }

            handleMovement() {
                const ROTATION_SPEED = 200; // Degrees per second
                const THRUST = 200; // Acceleration per second

                // Rotate left (A key)
                if (this.keyA.isDown) {
                    this.sprite.setAngularVelocity(-ROTATION_SPEED);
                }
                // Rotate right (D key)
                else if (this.keyD.isDown) {
                    this.sprite.setAngularVelocity(ROTATION_SPEED);
                }
                else {
                    this.sprite.setAngularVelocity(0);
                }

                // Thrust forward (W key)
                if (this.keyW.isDown) {
                    const angle = Phaser.Math.DegToRad(this.sprite.angle - 90);
                    const accelX = Math.cos(angle) * THRUST;
                    const accelY = Math.sin(angle) * THRUST;
                    this.sprite.setAcceleration(accelX, accelY);
                }
                else {
                    this.sprite.setAcceleration(0, 0);
                }
            }

            handleShooting() {
                const time = this.scene.time.now;
                if (this.spaceBar.isDown && time > this.lastFired) {
                    const bullets = this.scene.bullets;
                    for (let i = 0; i < this.weaponLevel; i++) {
                        const bullet = bullets.get();
                        if (bullet) {
                            const angle = Phaser.Math.DegToRad(this.sprite.angle - 90);
                            const spawnOffset = 20 + i * 5;
                            const bulletX = this.sprite.x + Math.cos(angle) * spawnOffset;
                            const bulletY = this.sprite.y + Math.sin(angle) * spawnOffset;

                            bullet.fire(bulletX, bulletY, angle, this.bulletSpeed);
                        }
                    }
                    this.lastFired = time + this.fireRate;

                    // Play shooting sound
                    this.scene.sound.play('shoot');
                }
            }

            takeDamage(amount) {
                this.health -= amount;
                console.log(`Player took damage. Health: ${this.health}`);
                if (this.health <= 0) {
                    this.sprite.setActive(false);
                    this.sprite.setVisible(false);

                    this.sprite.body.stop(); // Correct reference
                    this.sprite.body.reset(2000, 2000); // Reset to center or desired position
                    this.scene.score += 50; // Increment score
                    this.scene.scoreText.setText('Score: ' + this.scene.score);
                    console.log('Player destroyed');
                }
            }



            upgradeWeapon() {
                this.weaponLevel += 1;
                console.log(`Weapon upgraded. Level: ${this.weaponLevel}`);
            }
        }

        // ====================
        // Enemy Class with Logic Tree Behaviors
        // ====================
        class Enemy extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y, texture) {
                super(scene, x, y, texture);

                // Add enemy to the scene and physics world
                scene.add.existing(this);
                scene.physics.add.existing(this);

                // State machine properties
                this.State = {
                    IDLE: 'IDLE',
                    PATROL: 'PATROL',
                    ALERT: 'ALERT',
                    CHASE: 'CHASE',
                    ATTACK: 'ATTACK',
                    FLEE: 'FLEE',
                    SEARCH: 'SEARCH',
                    REGENERATION: 'REGENERATION',
                    STEALTH: 'STEALTH',
                    // Add other states as needed
                };

                this.state = this.State.PATROL; // Starting state
                this.player = null; // Reference to the player

                // Enemy properties
                this.health = 3;
                this.maxHealth = 3;
                this.speed = 100;
                this.detectionRange = 300;
                this.attackRange = 150;

                // State-specific properties
                this.alertTimer = 0;
                this.alertDuration = 5000; // 5 seconds
                this.searchTimer = 0;
                this.searchDuration = 5000; // 5 seconds
                this.lastKnownPosition = null;
                this.patrolPoints = [];
                this.currentPatrolIndex = 0;

                // Shooting properties
                this.lastFired = 0;
                this.fireRate = 1000; // Time between shots in milliseconds

                // Stealth properties
                this.isCloaked = false;
                this.stealthTimer = 0;
                this.stealthDuration = 5000; // 5 seconds

                // Other properties
                this.scoreIncremented = false;

                // Enable physics body
                this.body.setCollideWorldBounds(true);
            }

            initialize(player, type = 'default') {
                this.player = player;
                this.setActive(true);
                this.setVisible(true);
                this.scoreIncremented = false;
                this.setVelocity(0, 0);
                this.health = this.maxHealth;

                // Set initial state and properties based on enemy type
                switch (type) {
                    case 'stealth':
                        this.state = this.State.STEALTH;
                        console.log(`Enemy initialized with STEALTH`);
                        this.speed = 120;
                        break;
                    case 'sniper':
                        this.state = this.State.PATROL;
                        console.log(`Enemy initialized with PATROL`);
                        this.detectionRange = 500;
                        this.attackRange = 400;
                        this.speed = 80;
                        break;
                    default:
                        this.state = this.State.PATROL;
                        break;
                }

                // Define patrol points
                this.patrolPoints = this.generatePatrolPoints();
                this.currentPatrolIndex = 0;

                console.log(`Enemy initialized with health: ${this.health}, type: ${type}`);
            }

            update(time, delta) {
                switch (this.state) {
                    case this.State.IDLE:
                        this.idleBehavior();
                        break;
                    case this.State.PATROL:
                        this.patrolBehavior();
                        break;
                    case this.State.ALERT:
                        this.alertBehavior(delta);
                        break;
                    case this.State.CHASE:
                        this.chaseBehavior();
                        break;
                    case this.State.ATTACK:
                        this.attackBehavior(time);
                        break;
                    case this.State.FLEE:
                        this.fleeBehavior();
                        break;
                    case this.State.SEARCH:
                        this.searchBehavior(delta);
                        break;
                    case this.State.REGENERATION:
                        this.regenerationBehavior(delta);
                        break;
                    case this.State.STEALTH:
                        this.stealthBehavior(delta);
                        break;
                    default:
                        this.idleBehavior();
                        break;
                }
            }

            // Behavior Methods

            idleBehavior() {
                this.setVelocity(0, 0); // Stay stationary

                // Transition to PATROL after a delay or if player is detected
                if (this.canSeePlayer()) {
                    this.state = this.State.ALERT;
                }
            }

            patrolBehavior() {
                if (this.patrolPoints.length === 0) return;

                const targetPoint = this.patrolPoints[this.currentPatrolIndex];
                this.scene.physics.moveTo(this, targetPoint.x, targetPoint.y, this.speed);

                // Check if reached the patrol point
                if (Phaser.Math.Distance.Between(this.x, this.y, targetPoint.x, targetPoint.y) < 10) {
                    this.currentPatrolIndex = (this.currentPatrolIndex + 1) % this.patrolPoints.length;
                }

                // Transition to ALERT if player is detected
                if (this.canSeePlayer()) {
                    this.state = this.State.ALERT;
                    this.alertTimer = 0;
                }
            }

            alertBehavior(delta) {
                this.setVelocity(0, 0); // Stop moving
                this.alertTimer += delta;

                // Look around (rotate)
                this.setAngularVelocity(60); // Rotate at 60 degrees per second

                if (this.alertTimer >= this.alertDuration) {
                    this.alertTimer = 0;
                    this.state = this.State.PATROL; // Return to patrol
                    this.setAngularVelocity(0); // Stop rotating
                }

                // Transition to CHASE if player is detected
                if (this.canSeePlayer()) {
                    this.state = this.State.CHASE;
                    this.setAngularVelocity(0); // Stop rotating
                }
            }

            chaseBehavior() {
                if (!this.player) return;

                this.scene.physics.moveToObject(this, this.player.sprite, this.speed);

                // Transition to ATTACK if within attack range
                const distance = Phaser.Math.Distance.Between(this.x, this.y, this.player.sprite.x, this.player.sprite.y);
                if (distance <= this.attackRange) {
                    this.state = this.State.ATTACK;
                }

                // Transition to SEARCH if player is lost
                if (!this.canSeePlayer()) {
                    this.state = this.State.SEARCH;
                    this.lastKnownPosition = { x: this.player.sprite.x, y: this.player.sprite.y };
                    this.searchTimer = 0;
                }
            }

            attackBehavior(time) {
                // Face the player
                this.rotation = Phaser.Math.Angle.Between(this.x, this.y, this.player.sprite.x, this.player.sprite.y);

                // Fire at the player
                if (this.canFire(time)) {
                    this.fireAtPlayer();
                }

                // Transition to CHASE if player moves out of attack range
                const distance = Phaser.Math.Distance.Between(this.x, this.y, this.player.sprite.x, this.player.sprite.y);
                if (distance > this.attackRange) {
                    this.state = this.State.CHASE;
                }

                // Transition to FLEE if health is low
                if (this.health <= this.maxHealth * 0.3) {
                    this.state = this.State.FLEE;
                }
            }

            fleeBehavior() {
                if (!this.player) return;

                // Move away from the player
                const angle = Phaser.Math.Angle.Between(this.x, this.y, this.player.sprite.x, this.player.sprite.y) + Math.PI;
                this.setVelocity(Math.cos(angle) * this.speed, Math.sin(angle) * this.speed);

                // Transition to REGENERATION when safe
                const distance = Phaser.Math.Distance.Between(this.x, this.y, this.player.sprite.x, this.player.sprite.y);
                if (distance > this.detectionRange * 2) {
                    this.state = this.State.REGENERATION;
                }
            }

            searchBehavior(delta) {
                if (!this.lastKnownPosition) {
                    this.state = this.State.PATROL;
                    return;
                }

                // Move towards the last known position
                this.scene.physics.moveTo(this, this.lastKnownPosition.x, this.lastKnownPosition.y, this.speed);

                // Search timer
                this.searchTimer += delta;
                if (this.searchTimer >= this.searchDuration) {
                    this.state = this.State.PATROL;
                }

                // Transition back to CHASE if player is found
                if (this.canSeePlayer()) {
                    this.state = this.State.CHASE;
                }
            }

            regenerationBehavior(delta) {
                // Heal over time
                this.health += (this.maxHealth * 0.05) * (delta / 1000); // Heal 5% per second
                if (this.health >= this.maxHealth) {
                    this.health = this.maxHealth;
                    this.state = this.State.PATROL; // Return to patrol when fully healed
                }

                // Transition to FLEE if player is detected
                if (this.canSeePlayer()) {
                    this.state = this.State.FLEE;
                }
            }

            stealthBehavior(delta) {
                if (!this.isCloaked) {
                    this.isCloaked = true;
                    this.stealthTimer = 0;
                    this.setVisible(false);
                }

                this.stealthTimer += delta;

                // Move towards the player while cloaked
                this.scene.physics.moveToObject(this, this.player.sprite, this.speed);

                // Transition to ATTACK when close
                const distance = Phaser.Math.Distance.Between(this.x, this.y, this.player.sprite.x, this.player.sprite.y);
                if (distance <= this.attackRange / 2) {
                    this.setVisible(true);
                    this.isCloaked = false;
                    this.state = this.State.ATTACK;
                }

                // Uncloak after duration
                if (this.stealthTimer >= this.stealthDuration) {
                    this.setVisible(true);
                    this.isCloaked = false;
                    this.state = this.State.CHASE;
                }
            }

            // Helper Methods

            canSeePlayer() {
                if (!this.player) return false;
                const distance = Phaser.Math.Distance.Between(this.x, this.y, this.player.sprite.x, this.player.sprite.y);
                return distance <= this.detectionRange && !this.player.invisibilityActive;
            }

            canFire(time) {
                if (time > this.lastFired) {
                    this.lastFired = time + this.fireRate;
                    return true;
                }
                return false;
            }

            fireAtPlayer() {
                const bullets = this.scene.enemyBullets;
                const bullet = bullets.get();
                if (bullet) {
                    const angle = Phaser.Math.Angle.Between(this.x, this.y, this.player.sprite.x, this.player.sprite.y);
                    bullet.fire(this.x, this.y, angle, 300); // Enemy bullet speed
                }
            }

            generatePatrolPoints() {
                // Generate random patrol points within the game world
                const points = [];
                for (let i = 0; i < 4; i++) {
                    const x = Phaser.Math.Between(100, 3900);
                    const y = Phaser.Math.Between(100, 3900);
                    points.push({ x, y });
                }
                return points;
            }

            takeDamage(amount) {
                if (!this.active) return; // Prevent processing if already inactive

                this.health -= amount;
                console.log(`Enemy took damage. Health: ${this.health}`);

                if (this.health <= 0) {
                    if (!this.scoreIncremented) {
                        this.scene.addScore(50); // Increment score using scene's method
                        this.scoreIncremented = true;
                    }
                    this.disableBody(true, true);
                    console.log('Enemy destroyed');
                }
            }
        }


        // ====================
        // BossEnemy Class (New)
        // ====================
        class BossEnemy extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y, texture) {
                super(scene, x, y, texture);
                scene.add.existing(this);
                scene.physics.add.existing(this);

                this.health = 20; // Higher health for boss
                this.speed = 80;
                this.target = null;
                this.phase = 1;
                this.lastAttack = 0;
                this.attackCooldown = 2000; // Time between attacks in milliseconds
            }

            initialize(player) {
                this.target = player;
                this.setActive(true);
                this.setVisible(true);
                this.setVelocity(0, 0);
                this.setScale(1.5); // Larger size for boss
            }

            update(time, delta) {
                if (this.target) {
                    // **Move in a pattern (e.g., circular or back and forth)**
                    const distance = Phaser.Math.Distance.Between(this.x, this.y, this.target.sprite.x, this.target.sprite.y);
                    if (distance > 300) {
                        this.scene.physics.moveToObject(this, this.target.sprite, this.speed);
                    } else {
                        this.setVelocity(0, 0);
                    }

                    // **Boss Attack Patterns**
                    if (time > this.lastAttack) {
                        this.performAttack();
                        this.lastAttack = time + this.attackCooldown;
                    }
                }
            }

            performAttack() {
                // Example: Boss fires multiple bullets in spread
                const bulletCount = 8;
                const angleStep = Phaser.Math.PI2 / bulletCount;
                for (let i = 0; i < bulletCount; i++) {
                    const angle = i * angleStep;
                    const bullet = this.scene.bullets.get(this.x, this.y, 'bullet');
                    if (bullet) {
                        bullet.fire(this.x, this.y, angle, 400);
                    }
                }
                // Play boss attack sound
                this.scene.sound.play('shoot');
                console.log('Boss performed a spread attack');
            }

            takeDamage(amount) {
                this.health -= amount;
                console.log(`Boss Enemy took damage. Health: ${this.health}`);
                if (this.health <= 0) {
                    this.setActive(false);
                    this.setVisible(false);
                    this.body.stop(); // Stop any ongoing movement
                    this.body.reset(0, 0); // Reset position to origin
                    this.scene.score += 500; // Higher score for boss
                    this.scene.scoreText.setText('Score: ' + this.scene.score);
                    console.log('Boss Enemy destroyed');
                    
                    // **Reset hasBoss Flag**
                    this.scene.hasBoss = false;
                }
            }

        }

        // ====================
        // Asteroid Class (Refactored with Wrapping)
        // ====================
        class Asteroid extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y, texture) {
                super(scene, x, y, texture);
                scene.add.existing(this);
                scene.physics.add.existing(this);

                // Initialize default properties
                this.size = 1; // 1: Large, 2: Medium, 3: Small
                this.health = 3;
                this.speed = Phaser.Math.FloatBetween(50, 150);
                this.rotationSpeed = Phaser.Math.FloatBetween(-100, 100);
                this.setAngularVelocity(this.rotationSpeed);

                // **Remove World Bounds Collision**
                // this.setCollideWorldBounds(true);
                // this.body.onWorldBounds = true;

                // **Remove World Bounds Event Listener**
                // this.scene.physics.world.on('worldbounds', this.handleWorldBounds, this);
            }

            /**
             * Initializes the asteroid based on its size.
             * @param {number} size - The size category of the asteroid (1: Large, 2: Medium, 3: Small).
             */
            initialize(size) {
                this.size = size;
                switch (size) {
                    case 1:
                        this.setTexture('asteroid_large');
                        this.health = 3;
                        this.setScale(1.0);
                        break;
                    case 2:
                        this.setTexture('asteroid_medium');
                        this.health = 2;
                        this.setScale(0.7);
                        break;
                    case 3:
                        this.setTexture('asteroid_small');
                        this.health = 1;
                        this.setScale(0.4);
                        break;
                    default:
                        console.warn(`Unknown asteroid size: ${size}. Defaulting to Large.`);
                        this.setTexture('asteroid_large');
                        this.health = 3;
                        this.setScale(1.0);
                }

                // Randomize rotation speed for variety
                this.rotationSpeed = Phaser.Math.FloatBetween(-100, 100);
                this.setAngularVelocity(this.rotationSpeed);

                // Set random velocity
                const angle = Phaser.Math.FloatBetween(0, 2 * Math.PI);
                this.setVelocity(Math.cos(angle) * this.speed, Math.sin(angle) * this.speed);
            }

            /**
             * Updates the asteroid each frame.
             * Checks if the asteroid is off-screen and wraps it to the opposite side if necessary.
             * @param {number} time - The current time.
             * @param {number} delta - The time elapsed since the last frame.
             */
            update(time, delta) {
                // **Implement Wrapping Around the Game World**
                const worldWidth = this.scene.physics.world.bounds.width;
                const worldHeight = this.scene.physics.world.bounds.height;

                if (this.x < 0) {
                    this.x = worldWidth;
                } else if (this.x > worldWidth) {
                    this.x = 0;
                }

                if (this.y < 0) {
                    this.y = worldHeight;
                } else if (this.y > worldHeight) {
                    this.y = 0;
                }
            }

            /**
             * Handles damage taken by the asteroid.
             * @param {number} amount - The amount of damage to apply.
             */
            takeDamage(amount) {
                if (!this.active) return; // Prevent processing if already inactive

                this.health -= amount;
                console.log(`Asteroid took damage. Health: ${this.health}`);

                if (this.health <= 0) {
                    this.split();
                    this.disableAsteroid();
                }
            }

            /**
             * Splits the asteroid into smaller asteroids if it's not already the smallest size.
             */
            split() {
                if (this.size >= 3) return; // Smallest size does not split

                const newSize = this.size + 1;
                const numberOfSplits = 2; // Number of smaller asteroids to spawn

                for (let i = 0; i < numberOfSplits; i++) {
                    const asteroid = this.scene.asteroids.get(this.x, this.y, `asteroid_${newSize}`);
                    if (asteroid) {
                        // Ensure the new asteroid does not overlap the player or other objects
                        if (Phaser.Math.Distance.Between(asteroid.x, asteroid.y, this.scene.player.sprite.x, this.scene.player.sprite.y) > 100) {
                            asteroid.setActive(true);
                            asteroid.setVisible(true);
                            asteroid.initialize(newSize);
                            console.log(`Asteroid split into size ${newSize} at (${asteroid.x}, ${asteroid.y})`);
                        } else {
                            console.log('Split asteroid spawned too close to the player. Skipping.');
                            asteroid.disableAsteroid();
                        }
                    }
                }
            }

            /**
             * Disables the asteroid by deactivating and hiding it.
             */
            disableAsteroid() {
                this.setActive(false);
                this.setVisible(false);
                this.body.stop(); // Stop any ongoing movement
                this.body.reset(0, 0); // Reset position to origin
                /////////////////////////////////////////////////////
                ///////////////////////////////////////////////////
                this.scene.score += 30; // Increment score
                this.scene.scoreText.setText('Score: ' + this.scene.score);
                console.log('Asteroid destroyed and deactivated');
            }



        }
        // ====================
        // Game Scene with Updated Enemy Integration
        // ====================
        class GameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScene' });
            }

            preload() {
                // Preload assets if necessary (already handled in StartScene)
            }

            create() {
                // Initialize variables
                this.score = 0;
                this.level = 1;
                this.maxLevel = 20;
                this.hasBoss = false;

                // Set world bounds
                this.physics.world.setBounds(0, 0, 4000, 4000);

                // Create starfield
                this.createStarfield();

                // Create player
                this.player = new Player(this, 2000, 2000, 'player');

                // Create bullet groups
                this.bullets = this.physics.add.group({
                    classType: Bullet,
                    runChildUpdate: true,
                    maxSize: 100,
                });

                // Enemy bullets group
                this.enemyBullets = this.physics.add.group({
                    classType: Bullet,
                    runChildUpdate: true,
                    maxSize: 50,
                });

                // Create enemy, boss, and asteroid groups
                this.enemies = this.physics.add.group({
                    classType: Enemy,
                    runChildUpdate: true,
                });

                this.bosses = this.physics.add.group({
                    classType: BossEnemy,
                    runChildUpdate: true,
                });

                this.asteroids = this.physics.add.group({
                    classType: Asteroid,
                    runChildUpdate: true,
                });

                // Create power-up group
                this.powerUps = this.physics.add.group({
                    classType: PowerUp,
                    runChildUpdate: true,
                    maxSize: 10,
                });

                // Spawn initial entities
                this.spawnEnemies(this.level);
                this.spawnAsteroids(this.level);
                this.spawnPowerUps();
                this.spawnBoss(this.level);

                // Create UI
                this.createUI();

                // Set up collisions
                this.physics.add.overlap(this.bullets, this.enemies, this.handleBulletEnemyCollision, null, this);
                this.physics.add.overlap(this.bullets, this.asteroids, this.handleBulletAsteroidCollision, null, this);
                this.physics.add.overlap(this.bullets, this.bosses, this.handleBulletBossCollision, null, this);
                this.physics.add.overlap(this.player.sprite, this.enemies, this.handlePlayerEnemyCollision, null, this);
                this.physics.add.overlap(this.player.sprite, this.asteroids, this.handlePlayerAsteroidCollision, null, this);
                this.physics.add.overlap(this.player.sprite, this.powerUps, this.handlePowerUpCollision, null, this);
                this.physics.add.overlap(this.player.sprite, this.bosses, this.handlePlayerBossCollision, null, this);
                this.physics.add.overlap(this.player.sprite, this.enemyBullets, this.handlePlayerHitByEnemyBullet, null, this);

                // Camera setup
                this.cameras.main.setBounds(0, 0, 4000, 4000);
                this.cameras.main.startFollow(this.player.sprite, true, 0.05, 0.05);

                // Environmental Hazards
                this.createEnvironmentalHazards();

                // Level transition variables
                this.isTransitioning = false;

                // Play background music
                this.playBackgroundMusic();
            }

            update(time, delta) {
                if (!this.isTransitioning) {
                    this.player.update();
                    
                    // Check if counts have changed
                    const currentBulletCount = this.bullets.countActive();
                    const currentEnemyCount = this.enemies.countActive();

                    if (currentBulletCount !== this.previousBulletCount) {
                        this.bulletCountText.setText('Bullets: ' + currentBulletCount);
                        this.previousBulletCount = currentBulletCount;
                    }

                    if (currentEnemyCount !== this.previousEnemyCount) {
                        this.enemyCountText.setText('Enemies: ' + currentEnemyCount);
                        this.previousEnemyCount = currentEnemyCount;
                    }

                    // Adjust level progression condition
                    if (this.enemies.countActive() === 0 && (!this.hasBoss || this.bosses.countActive() === 0)) {
                        this.levelUp();
                    }

                    // Update environmental hazards
                    this.updateEnvironmentalHazards();
                }
            }

            createStarfield() {
                // Create a star texture if not already created
                if (!this.textures.exists('star')) {
                    const graphics = this.add.graphics();
                    graphics.fillStyle(0xffffff, 1);
                    graphics.fillCircle(2, 2, 2);
                    graphics.generateTexture('star', 4, 4);
                    graphics.destroy();
                }

                // Create star group
                this.starGroup = this.add.group({
                    key: 'star',
                    repeat: 500,
                    setXY: { x: 0, y: 0, stepX: 8, stepY: 6 },
                });

                this.starGroup.children.iterate(function (star) {
                    star.setX(Phaser.Math.Between(0, 4000));
                    star.setY(Phaser.Math.Between(0, 4000));
                    star.setAlpha(Phaser.Math.FloatBetween(0.2, 1));
                });
            }

            spawnEnemies(level) {
                const enemyCount = 5 + level * 2;
                for (let i = 0; i < enemyCount; i++) {
                    const x = Phaser.Math.Between(100, 3900);
                    const y = Phaser.Math.Between(100, 3900);

                    // Randomly assign enemy types
                    const types = ['default', 'stealth', 'sniper'];
                    const randomType = Phaser.Utils.Array.GetRandom(types);

                    const enemy = this.enemies.get(x, y, 'enemy');
                    if (enemy) {
                        if (Phaser.Math.Distance.Between(x, y, this.player.sprite.x, this.player.sprite.y) > 100) {
                            enemy.setActive(true);
                            enemy.setVisible(true);
                            enemy.initialize(this.player, randomType);
                        } else {
                            enemy.disableBody(true, true);
                        }
                    }
                }
                console.log(`Spawned ${enemyCount} enemies for Level ${level}`);
            }

            spawnBoss(level) {
                // Spawn a boss every 5 levels
                if (level % 5 === 0) {
                    const x = Phaser.Math.Between(1000, 3000);
                    const y = Phaser.Math.Between(1000, 3000);
                    const boss = this.bosses.get(x, y, 'boss');
                    if (boss) {
                        if (Phaser.Math.Distance.Between(x, y, this.player.sprite.x, this.player.sprite.y) > 200) {
                            boss.setActive(true);
                            boss.setVisible(true);
                            boss.initialize(this.player);
                            console.log(`Boss spawned at (${x}, ${y}) for Level ${level}`);
                            this.hasBoss = true;
                        } else {
                            boss.disableBody(true, true);
                            this.hasBoss = false;
                        }
                    }
                } else {
                    this.hasBoss = false;
                }
            }

            spawnAsteroids(level) {
                const asteroidCount = 10 + level * 3;
                for (let i = 0; i < asteroidCount; i++) {
                    const size = Phaser.Math.Between(1, 3);
                    const x = Phaser.Math.Between(100, 3900);
                    const y = Phaser.Math.Between(100, 3900);
                    const asteroid = this.asteroids.get(x, y, `asteroid_${size}`);
                    if (asteroid) {
                        if (Phaser.Math.Distance.Between(x, y, this.player.sprite.x, this.player.sprite.y) > 100) {
                            asteroid.setActive(true);
                            asteroid.setVisible(true);
                            asteroid.initialize(size);
                        } else {
                            asteroid.disableAsteroid();
                        }
                    }
                }
                console.log(`Spawned ${asteroidCount} asteroids for Level ${level}`);
            }

            spawnPowerUps() {
                const mapWidth = 4000;
                const mapHeight = 4000;
                const corners = [
                    { x: 50, y: 50 },
                    { x: mapWidth - 50, y: 50 },
                    { x: 50, y: mapHeight - 50 },
                    { x: mapWidth - 50, y: mapHeight - 50 },
                ];

                const powerUpTypes = ['shield', 'fire_rate', 'invisibility', 'warp'];

                corners.forEach((corner, index) => {
                    const type = powerUpTypes[index % powerUpTypes.length];
                    const powerUp = this.powerUps.get(corner.x, corner.y, type);
                    if (powerUp) {
                        if (Phaser.Math.Distance.Between(corner.x, corner.y, this.player.sprite.x, this.player.sprite.y) > 100) {
                            powerUp.setActive(true);
                            powerUp.setVisible(true);
                            powerUp.type = type;
                            console.log(`Power-Up '${type}' spawned at (${corner.x}, ${corner.y})`);
                        } else {
                            powerUp.disableBody(true, true);
                        }
                    }
                });
            }

// In your GameScene class

            // Add this to GameScene shutdown
            shutdown() {
                this.bullets.clear(true, true);
                this.enemies.clear(true, true);
                this.asteroids.clear(true, true);
                this.time.removeAllEvents();
                this.events.off(); // Remove all event listeners if any
            }


            createUI() {
                // Existing UI code
                this.scoreText = this.add.text(16, 16, 'Score: 0', {
                    fontSize: '20px',
                    fill: '#ffffff',
                }).setScrollFactor(0);

                this.levelText = this.add.text(16, 40, 'Level: 1', {
                    fontSize: '20px',
                    fill: '#ffffff',
                }).setScrollFactor(0);

                // Health Bar
                this.healthBar = this.add.graphics();
                this.healthBar.fillStyle(0xff0000, 1);
                this.healthBar.fillRect(16, 70, 100, 20); // x, y, width, height
                this.healthBar.setScrollFactor(0);

                // **Add Bullets and Enemies Counts**
                this.bulletCountText = this.add.text(16, 100, 'Bullets: 0', {
                    fontSize: '16px',
                    fill: '#ffffff',
                }).setScrollFactor(0);

                this.enemyCountText = this.add.text(16, 120, 'Enemies: 0', {
                    fontSize: '16px',
                    fill: '#ffffff',
                }).setScrollFactor(0);

                // Initialize previous counts
                this.previousBulletCount = 0;
                this.previousEnemyCount = 0;
            }


            updateHealthBar() {
                const healthPercentage = Phaser.Math.Clamp(this.player.health / 3, 0, 1);
                this.healthBar.clear();
                this.healthBar.fillStyle(0xff0000, 1);
                this.healthBar.fillRect(16, 70, 100 * healthPercentage, 20);
            }

            addScore(points) {
                this.score += points;
                this.scoreText.setText('Score: ' + this.score);
            }

            handleBulletEnemyCollision(bullet, enemy) {
                if (enemy instanceof Enemy) {
                    bullet.disableBullet();
                    if (enemy.active) {
                        enemy.takeDamage(1);
                        this.sound.play('explosion');
                    }
                }
            }

            handleBulletAsteroidCollision(bullet, asteroid) {
                if (asteroid instanceof Asteroid) {
                    bullet.disableBullet();
                    asteroid.takeDamage(1);
                    this.sound.play('explosion');
                }
            }

            handleBulletBossCollision(bullet, boss) {
                if (boss instanceof BossEnemy) {
                    bullet.disableBullet();
                    boss.takeDamage(1);
                    this.sound.play('explosion');
                }
            }

            handlePlayerEnemyCollision(playerSprite, enemy) {
                if (enemy instanceof Enemy) {
                    if (this.player.shieldActive) {
                        console.log('Shield absorbed enemy collision');
                    } else {
                        this.player.takeDamage(1);
                    }

                    enemy.takeDamage(1);
                    this.sound.play('collision');

                    if (this.player.health <= 0) {
                        this.gameOver();
                    }

                    this.updateHealthBar();
                }
            }

            handlePlayerAsteroidCollision(playerSprite, asteroid) {
                if (asteroid instanceof Asteroid) {
                    if (this.player.shieldActive) {
                        console.log('Shield absorbed asteroid collision');
                    } else {
                        this.player.takeDamage(1);
                    }

                    asteroid.takeDamage(1);
                    this.sound.play('collision');

                    if (this.player.health <= 0) {
                        this.gameOver();
                    }

                    this.updateHealthBar();
                }
            }

            handlePlayerBossCollision(playerSprite, boss) {
                if (boss instanceof BossEnemy) {
                    if (this.player.shieldActive) {
                        console.log('Shield absorbed boss collision');
                    } else {
                        this.player.takeDamage(2);
                    }

                    boss.takeDamage(2);
                    this.sound.play('collision');

                    if (this.player.health <= 0) {
                        this.gameOver();
                    }

                    this.updateHealthBar();
                }
            }

            handlePowerUpCollision(playerSprite, powerUp) {
                if (powerUp instanceof PowerUp) {
                    switch (powerUp.type) {
                        case 'shield':
                            this.activateShield();
                            break;
                        case 'fire_rate':
                            this.activateFireRateBooster();
                            break;
                        case 'invisibility':
                            this.activateInvisibilityCloak();
                            break;
                        case 'warp':
                            this.activateWarp();
                            break;
                        default:
                            console.warn('Unknown Power-Up Type:', powerUp.type);
                    }

                    powerUp.disableBody(true, true);
                    this.sound.play('powerup');
                    console.log(`Player collected '${powerUp.type}' power-up`);
                }
            }

            handlePlayerHitByEnemyBullet(playerSprite, bullet) {
                bullet.disableBullet();
                if (!this.player.shieldActive) {
                    this.player.takeDamage(1);
                    this.updateHealthBar();
                    this.sound.play('collision');

                    if (this.player.health <= 0) {
                        this.gameOver();
                    }
                } else {
                    console.log('Shield absorbed enemy bullet');
                }
            }

            activateShield() {
                if (this.player.shieldActive) return;

                this.player.shieldActive = true;
                this.player.sprite.setTint(0x00ff00);

                this.time.delayedCall(5000, () => {
                    this.player.shieldActive = false;
                    this.player.sprite.clearTint();
                });

                this.sound.play('shield');
                console.log('Shield Activated');
            }

            activateFireRateBooster() {
                if (this.player.fireRateBoosterActive) return;

                this.player.fireRateBoosterActive = true;
                this.player.fireRate /= 2;

                this.time.delayedCall(5000, () => {
                    this.player.fireRateBoosterActive = false;
                    this.player.fireRate *= 2;
                });

                this.sound.play('fire_rate_booster');
                console.log('Fire Rate Booster Activated');
            }

            activateInvisibilityCloak() {
                if (this.player.invisibilityActive) return;

                this.player.invisibilityActive = true;
                this.player.sprite.setTint(0x0000ff);
                this.player.sprite.alpha = 0.5;

                this.time.delayedCall(5000, () => {
                    this.player.invisibilityActive = false;
                    this.player.sprite.clearTint();
                    this.player.sprite.alpha = 1;
                });

                this.sound.play('invisibility');
                console.log('Invisibility Cloak Activated');
            }

            activateWarp() {
                const safeAreas = [
                    { x: 2000, y: 2000 },
                    { x: 1000, y: 1000 },
                    { x: 3000, y: 3000 },
                    { x: 2500, y: 3500 },
                ];

                const randomIndex = Phaser.Math.Between(0, safeAreas.length - 1);
                const selectedSafeArea = safeAreas[randomIndex];

                this.player.sprite.setPosition(selectedSafeArea.x, selectedSafeArea.y);

                this.sound.play('warp');
                this.cameras.main.flash(300, 0, 0, 255);

                console.log(`Player warped to (${selectedSafeArea.x}, ${selectedSafeArea.y})`);
            }

            levelUp() {
                if (this.level >= this.maxLevel) {
                    this.victory();
                    return;
                }

                this.level += 1;
                this.levelText.setText('Level: ' + this.level);
                this.isTransitioning = true;

                this.sound.play('level_up');

                const transitionText = this.add.text(this.cameras.main.midPoint.x, this.cameras.main.midPoint.y, `Level ${this.level}`, {
                    fontSize: '64px',
                    fill: '#ffffff',
                }).setOrigin(0.5).setDepth(1000);

                this.cameras.main.fadeOut(1000, 0, 0, 0);
                this.time.delayedCall(1000, () => {
                    transitionText.destroy();

                    this.spawnEnemies(this.level);
                    this.spawnAsteroids(this.level);
                    this.spawnPowerUps();
                    this.spawnBoss(this.level);

                    this.provideUpgrades();

                    this.cameras.main.fadeIn(1000, 0, 0, 0);
                    this.isTransitioning = false;

                    console.log(`Level Up! Now at Level ${this.level}`);
                });
            }

            provideUpgrades() {
                this.player.upgradeWeapon();
            }

            gameOver() {
                if (this.backgroundMusic) {
                    this.backgroundMusic.stop();
                }

                this.scene.start('GameOverScene', { score: this.score });
            }

            victory() {
                if (this.backgroundMusic) {
                    this.backgroundMusic.stop();
                }

                this.scene.start('VictoryScene', { score: this.score });
            }

            createEnvironmentalHazards() {
                this.hazards = this.add.group();

                if (this.level === 2) {
                    const storm = this.add.rectangle(2000, 2000, 4000, 4000, 0x888888, 0.1);
                    this.hazards.add(storm);
                }
            }

            updateEnvironmentalHazards() {
                // Implement effects of environmental hazards
            }

            playBackgroundMusic() {
                this.backgroundMusic = this.sound.add('boss_theme', { loop: true, volume: 0.5 });
                this.backgroundMusic.play();
            }
        }

        // ====================
        // Game Over Scene
        // ====================
        class GameOverScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameOverScene' });
            }

            init(data) {
                this.finalScore = data.score;
            }

            create() {
                // Create background
                this.cameras.main.setBackgroundColor('#000');

                // Game Over Text
                this.add.text(this.scale.width / 2, this.scale.height / 2 - 100, 'Game Over', {
                    fontSize: '48px',
                    fill: '#ff0000'
                }).setOrigin(0.5);

                // Final Score
                this.add.text(this.scale.width / 2, this.scale.height / 2, `Score: ${this.finalScore}`, {
                    fontSize: '32px',
                    fill: '#ffffff'
                }).setOrigin(0.5);

                // Restart Instruction
                this.add.text(this.scale.width / 2, this.scale.height / 2 + 100, 'Press SPACE to Restart', {
                    fontSize: '24px',
                    fill: '#ffffff'
                }).setOrigin(0.5);

                // Input
                this.spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
            }

            update(time, delta) {
                if (Phaser.Input.Keyboard.JustDown(this.spaceBar)) {
                    this.scene.start('GameScene');
                }
            }
        }

        // ====================
        // Victory Scene (New)
        // ====================
        class VictoryScene extends Phaser.Scene {
            constructor() {
                super({ key: 'VictoryScene' });
            }

            init(data) {
                this.finalScore = data.score;
            }

            create() {
                // Create background
                this.cameras.main.setBackgroundColor('#000');

                // Victory Text
                this.add.text(this.scale.width / 2, this.scale.height / 2 - 100, 'Victory!', {
                    fontSize: '48px',
                    fill: '#00ff00'
                }).setOrigin(0.5);

                // Final Score
                this.add.text(this.scale.width / 2, this.scale.height / 2, `Final Score: ${this.finalScore}`, {
                    fontSize: '32px',
                    fill: '#ffffff'
                }).setOrigin(0.5);

                // Restart Instruction
                this.add.text(this.scale.width / 2, this.scale.height / 2 + 100, 'Press SPACE to Play Again', {
                    fontSize: '24px',
                    fill: '#ffffff'
                }).setOrigin(0.5);

                // Input
                this.spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
            }

            update(time, delta) {
                if (Phaser.Input.Keyboard.JustDown(this.spaceBar)) {
                    this.scene.start('GameScene');
                }
            }
        }

        // ====================
        // Phaser Game Configuration
        // ====================
        const config = {
            type: Phaser.AUTO,
            width: 1300, // Viewport width
            height: 800, // Viewport height
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 }, // No gravity for shooter
                    debug: false, // Set to true for debugging
                }
            },
            scene: [StartScene, GameScene, GameOverScene, VictoryScene], // Added VictoryScene
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };

        // Initialize the game
        const game = new Phaser.Game(config);
    </script>
</body>
</html>
